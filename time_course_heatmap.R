# Cluster genes by time-course expression patterns and create a heatmap of the clusters.
# This script is inspired by a script by Dr. Dennis Goldfarb from Washington University (https://github.com/GoldfarbLab/H522_paper_figures/blob/master/Figure5.R).



# ---
# title: "Time Course Heatmap"
# author: "Yiqing Wang"
# date: "9/30/2022"
# input: count files and differential gene expression (DGE) analysis results by edgeR
# output: clustered time-course z-score heatmap in PNG format
# ---



library(dplyr)
library(ggplot2)
library(stringr)
library(edgeR)
library(ConsensusClusterPlus)
library(ComplexHeatmap)
library(circlize)
library(RColorBrewer)



######  arguments  ######

exp_name <- "name_of_choice"
path <- "path/of/choice"

# path to count files, one file for each sample. Filenames should be in "condition_replicate_timepoint" format.
counts_path <- file.path("folder/with/count/files/for/each/sample")

# folder with edgeR DGE analysis result tables
# the tables were generated by topTags() function and includes logFC, logCPM, pvalue, and FDR columns for each gene
diffex_path <- file.path(path, "diffex")

filelist <- list.files(path = counts_path)

rep_no <- 2 # number of replicates for each condition and timepoint

num_clust <- 12 # number of clusters to be generated by consensus clustering
num_rep <- 100 # number of subsamples for consensus clustering

save_tables <- T

# a gene-only GTF file whose order of genes is the same as in the count files
gtf_path <- "path/to/gtf"

# custom sample order in the columns of the heatmap
col_order <- c("cond1_rep1_0h", "cond1_rep2_0h", "cond1_rep1_3h", "cond1_rep2_3h",
               "cond1_rep1_6h", "cond1_rep2_6h", "cond1_rep1_12h", "cond1_rep2_12h",
               "cond2_rep1_0h", "cond2_rep2_0h", "cond2_rep1_3h", "cond2_rep2_3h",
               "cond2_rep1_6h", "cond2_rep2_6h", "cond2_rep1_12h", "cond2_rep2_12h",)

outdir <- file.path(path, "outputs")
dir.create(path = outdir)

plotdir <- file.path(path, "plots")
dir.create(path = plotdir)



######  functions  ######

# convert an array to Gaussian distribution
gauss <- function(x) {
  (x - mean(x)) / sd(x)
}

# convert ensembl gene ids to gene symbols using a gene-only GTF
geneNameConversion <- function(counts, gtf_path) {
  gtf <- read.table(file = gtf_path, sep = " ")

  gene_id <- as.character(gtf[, 2])
  gene_id <- substr(gene_id, start = 1, stop = nchar(gene_id) - 1) # getting rid of the ";" at the end
  stopifnot(gene_id == row.names(counts))

  gene_names <- as.character(gtf[, 6])
  gene_names <- substr(gene_names, start = 1, stop = nchar(gene_names) - 1)
  row.names(counts) <- gene_names

  return(counts)
}



######  gathering counts, getting DE genes, z-score  ######

# make sample matrix

conditions <- sapply(strsplit(filelist, split = "_"), function(x) x[1])
experiments <- sapply(strsplit(filelist, split = "_"), function(x) x[2])
timepoints <- sapply(strsplit(filelist, split = "_"), function(x) x[3])

design <- data.frame(conditions = conditions,
                     timepoints = timepoints,
                     experiments = experiments)
row.names(design) <- filelist



# load counts data into a combined table

counts <- NULL

for (file in filelist) {
  table <- read.table(file = file.path(counts_path, file),
                      header = F, sep = '\t', col.names = c('id', file))
  counts <- cbind(counts, table[, 2])
}

rownames(counts) <- table[, 1]
colnames(counts) <- filelist

counts <- geneNameConversion(counts = counts, gtf_path = gtf_path)

if (save_tables) {
  write.table(x = counts,
              file = file.path(outdir, paste0(exp_name, "_rawCountsTable")),
              quote = F, sep = "\t", col.names = NA)
}



# count filtering, deduplication, log CPM calculation

dge <- DGEList(counts = counts)

og_dge <- dge # saves a copy of original dge
# dge <- og_dge

print(paste0("before filtering: ", nrow(dge)), quote = F)
keep <- rowSums(cpm(dge) > 1) >= rep_no
print(paste0("after filtering: ", sum(keep)), quote = F)
dge <- dge[keep, , keep.lib.sizes = F]

# remove genes with duplicate gene symbols
dups <- rownames(dge)[duplicated(rownames(dge))]
dge <- dge[!(row.names(dge) %in% dups), , keep.lib.sizes = F]
print(paste0("after deduplication: ", nrow(dge)), quote = F)

if (save_tables) write.table(dge$counts, file = file.path(outdir, paste0(exp_name, "_filteredCountsTable")), quote = F, sep = "\t", col.names = NA)

dge <- calcNormFactors(dge)
cpm <- cpm(dge, log = T, prior.count = 1)

if (save_tables) write.table(cpm, file = file.path(outdir, paste0(exp_name, "_cpm")), quote = F, sep = "\t", col.names = NA)



# load edgeR DGE result tables and saves a union of significantly differentially expressed genes

de_union <- NULL

for (file in dir(path = diffex_path)) {
  # read in table
  fname <- unlist(strsplit(file, split = "_diff"))[1]
  table <- read.delim(file.path(diffex_path, file), row.names = 1)
  # save the sig genes
  sig <- row.names(table[abs(table[, "logFC"]) > 1 & table[, "FDR"] < 0.05, ])
  de_union <- union(de_union, sig)
}

print(paste0("number of union DE genes: ", length(de_union)), quote = F)


# take intersect and find corresponding cpm values
union_cpm <- cpm[intersect(de_union, row.names(cpm)), ]

# reorder and transform
union_cpm <- union_cpm[ , col_order]
if (save_tables) {
  write.table(union_cpm, file = file.path(outdir, paste0(exp_name, "_sigCPM")),
              quote = F, sep = "\t", col.names = NA)
}

# z-score calculation
g_table <- t(apply(union_cpm, 1, gauss))



######  clustering  ######

# create clusters using K-means clustering

cluster <- ConsensusClusterPlus(t(g_table),
                                maxK = num_clust, reps = num_rep,
                                pItem = 0.85, pFeature = 1,
                                clusterAlg = "km",
                                # clusterAlg = "hc",
                                # innerLinkage = "complete",
                                # finalLinkage = "ward.D2",
                                distance = "euclidean",
                                plot = "pdf",
                                title = outdir,
                                seed = 8220)

save(cluster, file = file.path(outdir, paste0(exp_name, "_cluster.RData")))

load(file = file.path(outdir, paste0(exp_name, "_cluster.RData")))

clust_info <- cluster[[num_clust]][["consensusClass"]]
orig_clust_info <- clust_info
clust_info_df <- data.frame(clust_info)
write.table(clust_info_df, file = file.path(outdir, paste0(exp_name, "_origClusterInfo")),
            sep = "\t", quote = F, col.names = NA)

g_table <- data.frame(g_table)
rm(cluster)

if (save_tables) {
  write.table(g_table, file = file.path(outdir, paste0(exp_name, "_origZscore")),
              quote = F, sep = "\t", col.names = NA)
}



# plot clusters

# clusters to remove > should be marked 99

pos.1 <- which(clust_info == 1)
pos.2 <- which(clust_info == 2)
pos.3 <- which(clust_info == 3)
pos.4 <- which(clust_info == 4)
pos.5 <- which(clust_info == 5)
pos.6 <- which(clust_info == 6)
pos.7 <- which(clust_info == 7)
pos.8 <- which(clust_info == 8)
pos.9 <- which(clust_info == 9)
pos.10 <- which(clust_info == 10)
pos.11 <- which(clust_info == 11)
pos.12 <- which(clust_info == 12)


# make custom order of clusters to show in the heatmap, can also merge clusters

clust_info[pos.1] <- 1
clust_info[pos.2] <- 2
clust_info[pos.3] <- 4
clust_info[pos.4] <- 3
clust_info[pos.5] <- 7
clust_info[pos.6] <- 6
clust_info[pos.7] <- 12
clust_info[pos.8] <- 5
clust_info[pos.9] <- 8
clust_info[pos.10] <- 9
clust_info[pos.11] <- 10
clust_info[pos.12] <- 11

clust_info <- clust_info[clust_info!=99]
g_table_cut <- g_table # for when no cluster is removed
g_table_cut <- g_table[(intersect(rownames(g_table),
                                  names(clust_info[clust_info!=99]))),]

print(paste0("min z-score: ", min(g_table_cut)), quote = F)
print(paste0("max z-score: ", max(g_table_cut)), quote = F)


clust_info_df <- data.frame(clust_info)
write.table(clust_info_df, file = file.path(outdir, paste0(exp_name, "_clusterInfo")),
            sep = "\t", quote = F, col.names = NA)

if (save_tables) {
  write.table(g_table_cut, file = file.path(outdir, paste0(exp_name, "_heatmapTable")),
              quote = F, sep = "\t", col.names = NA)
}

save(g_table_cut, file = file.path(outdir, paste0(exp_name, "_heatmapTable.RData")))



# custom-select genes to be labeled in the heatmap

isg <- c("geneA", "geneB")
cta <- c("geneC", "geneD")
other <- c("geneE", "geneF", "geneG")

genes <- c(isg, cta, other)
genes_tc <- genes[genes %in% names(clust_info)]
print(genes_tc)
gene_label_pos <- which(row.names(g_table_cut) %in% genes_tc)
gene_label <- row.names(g_table_cut)[gene_label_pos]

label_color <- function(gene) {
  if (gene %in% isg) return("tomato")
  else if (gene %in% cta) return("seagreen")
  else return("royalblue")
}

gene_label_col <- sapply(X = gene_label, FUN = label_color)




######  plotting heatmap  ######

# color palette
colPalette <- c("#AEC7E87F", "#98DF8A7F", "#FF98967F",
                "#C49C947F", "#C5B0D57F", "#FFBB787F", "#D627287F",
                "#FF7F0E7F", "#9467BD7F", "#8C564B7F", "#E377C27F",
                "#F7B6D27F")


# split columns to different sections
split_order <- c(rep("a", 8), rep("b", 8))

col_fun <- circlize::colorRamp2(breaks = seq(-3, 3, length = 256),
                                colors = rev(colorRampPalette(brewer.pal(10, "RdBu"))(256)))

cluster.rowAnnot <- rowAnnotation(block = anno_block(gp = gpar(fill = colPalette, col = NA)),
                                  width = unit(1, "mm"))

# gene labels on the right
gene.rowAnnot <- rowAnnotation(gene.name = anno_mark(at = gene_label_pos,
                                                     labels = gene_label,
                                                     labels_gp = gpar(fontsize = 7, col = gene_label_col),
                                                     link_gp = gpar(lwd = 0.5),
                                                     link_width = unit(4, "mm"),
                                                     padding = unit(0.5, "mm")))


# custom column label for samples
col_label <- sapply(strsplit(col_order, split = "_"), function(x) paste(x[2], x[3], sep = "_"))

# global option to set title padding to fix column title position problem
ht_opt$TITLE_PADDING = unit(c(3, 3), "points")

h2 <- Heatmap(as.matrix(g_table_cut),
              column_title = c("Condition1", "Condtion2"),
              column_title_side = "bottom",
              column_title_gp = gpar(fontsize = 9, fill = "white", col = "black", border = "black"),
              show_row_names = F,
              row_names_gp = gpar(fontsize = 6),
              column_labels = col_label,
              column_names_gp = gpar(fontsize = 6),
              name = "z-score",
              col = col_fun,
              # legends
              show_heatmap_legend = F,
              heatmap_legend_param = list(color_bar = "continuous",
                                          title_gp = gpar(fontsize = 6),
                                          labels_gp = gpar(fontsize = 6),
                                          grid_width = unit(2, units = "mm")),
              # clustering
              cluster_columns = F,
              clustering_distance_rows = "euclidean",
              cluster_row_slices = F,
              show_row_dend = F,
              split = clust_info, # split rows based on clusters
              left_annotation = cluster.rowAnnot,
              right_annotation = gene.rowAnnot,

              # splitting
              column_split = factor(split_order),
              cluster_column_slices = F,
              column_gap = unit(2, units = "mm"),

              # labels
              row_title_rot = 0,
              row_title_gp = gpar(fontsize = 7),

              # size
              width = ncol(g_table_cut) * 0.2,
              use_raster = F
)


color_legend <- Legend(col_fun = col_fun,
                       title = "z-score",
                       title_gp = gpar(fontsize = 7),
                       title_position = "topcenter",
                       labels_gp = gpar(fontsize = 7),
                       grid_width = unit(2, units = "mm"))

gene_color_legend <- Legend(labels = c("ISG", "CTA", "Others"),
                            title = "Gene Family",
                            legend_gp = gpar(fill = c("tomato", "seagreen", "royalblue")),
                            title_gp = gpar(fontsize = 7),
                            labels_gp = gpar(fontsize = 7))


png(file.path(plotdir, paste0(exp_name, "_heatmap.png")), height = 2000, width = 1000, res = 300)
draw(h2,
     column_title = paste0("Differentially Expressed Genes\nn = ", nrow(g_table_cut)),
     column_title_gp = gpar(fontsize = 8)) # the big column title is drawn separately here
draw(gene_color_legend, x = unit(x = 0.9, units = "npc"), y = unit(x = 0.2, units = "npc"))
draw(color_legend, x = unit(0.9, "npc"), y = unit(0.7, "npc"))
dev.off()
